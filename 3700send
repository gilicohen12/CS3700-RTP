#!/usr/bin/env -S python3 -u

import argparse, socket, time, sys, hashlib
import select

DATA_SIZE = 1024
RTT = 1
WINDOW_SIZE = 4

class Sender:
    MESSAGE = bytes([0])
    ACK = bytes([1])
    RTT = 1.0
    adjust_RTT = 2
    ORIG_RTT_RATIO = 0.7

    CHECKSUM_SIZE = 20

    packets_out = []
    window = 14
    WINDOW_INCREASE = 1
    WINDOW_REDUCE_RATIO = 0.55
    WINDOW_MIN = 2
    time_last_sent = {}

    def __init__(self, host, port):
        self.host = host
        self.remote_port = int(port)
        self.log(f"Sender starting up using port {self.remote_port}")
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))
        self.waiting = False
        self.packets = []
        data = sys.stdin.buffer.read(DATA_SIZE)
        self.sequence_number = 0
        while data:
            self.packets.append(self.prepare_packet(self.MESSAGE, self.seq_num(self.sequence_number), data))
            data = sys.stdin.buffer.read(DATA_SIZE)
            self.sequence_number += 1
        self.log(f"Fully chunked {self.sequence_number} packets!")
        self.acked_packets = []

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, message: bytes):
        self.socket.sendto(message, (self.host, self.remote_port))

    def prepare_packet(self, type: bytes, seq_num: bytes, message: bytes) -> bytes:
        header = type + seq_num
        checksum = hashlib.sha1(header + message).digest()
        return header + message + checksum

    def seq_num(self, num: int) -> bytes:
        return bytes([(num // 256) % 256, num % 256])

    def seq_from(self, msg: bytes) -> int:
        return int.from_bytes(msg[1:3], byteorder='big')

    def min_not_sent(self):
        m = 0
        while m in self.acked_packets or m in self.packets_out:
            m += 1
        return m

    def is_msg_not_corrupted(self, b: bytes) -> bool:
        received_digest = b[-self.CHECKSUM_SIZE:]
        calculated_digest = hashlib.sha1(b[:-self.CHECKSUM_SIZE]).digest()
        return received_digest == calculated_digest

    def run(self):
        while True:
            sockets = [self.socket, sys.stdin] if not self.waiting else [self.socket]

            # Retransmission Timeout Handling
            for i in range(len(self.packets_out) - 1, -1, -1): # Iterate in reverse
                p = self.packets_out[i]
                if time.time() - self.time_last_sent[p] > self.RTT * self.adjust_RTT:
                    self.packets_out.remove(p)
                    self.window = max(self.window * self.WINDOW_REDUCE_RATIO, self.WINDOW_MIN) # Window Size Adjustment

            self.waiting = len(self.packets_out) >= self.window

            socks = select.select(sockets, [], [], 0.1)[0]
            for conn in socks:
                if conn == self.socket:
                    k, _ = conn.recvfrom(65535)

                    if self.is_msg_not_corrupted(k) and k[0:1] == self.ACK:
                        self.log(f"Received message '{k}'")
                        acked = self.seq_from(k)
                        if acked in self.packets_out:
                            self.packets_out.remove(acked)
                            self.acked_packets.append(acked)
                            self.RTT = (self.ORIG_RTT_RATIO * self.RTT) + ((1 - self.ORIG_RTT_RATIO) * (time.time() - self.time_last_sent[acked]))
                            print(self.RTT)
                            self.window += self.WINDOW_INCREASE

                        self.waiting = len(self.packets_out) >= self.window
                    else:
                        self.log(f"Received bad message '{k}'")
                elif conn == sys.stdin:
                    if len(self.acked_packets) == self.sequence_number:
                        self.log("All done!")
                        sys.exit(0)

                    sending = self.min_not_sent()
                    if sending < len(self.packets):
                        msg = self.packets[sending]
                        self.packets_out.append(sending)
                        self.log(f"Sending message '{sending}', packets_out: {self.packets_out}")
                        self.send(msg)
                        self.time_last_sent[sending] = time.time()
                        self.waiting = len(self.packets_out) >= self.window
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('host', type=str, help="Remote host to connect to")
    parser.add_argument('port', type=int, help="UDP port number to connect to")
    args = parser.parse_args()
    sender = Sender(args.host, args.port)
    sender.run()
